/********* CONFIG *********/
const TOKEN_MINT = "7W4geAJyy7hxuPXESMMBaW8Zi4MbhVN9uvt6BJ2SEPAV"; // <- put your Contract Address here
// If you have a backend ready, set your API root here:
const API = ""; // e.g. "https://your-backend.onrender.com" or keep "" to use the tiny simulator

// If you want the Open Swap button to prefill a DEX URL, set it here:
const DEX_URL = ""; // e.g. "https://jup.ag/swap/SOL-<MINT>"

/********* DOM *********/
const canvas = document.getElementById("org-canvas");
const ctx = canvas.getContext("2d", { alpha: true });

const healthBar = document.getElementById("healthBar");
const healthPct = document.getElementById("healthPct");
const mutBar = document.getElementById("mutBar");
const mutPct = document.getElementById("mutPct");

const stageNum = document.getElementById("stageNum");
const statusEl = document.getElementById("status");
const heartbeat = document.getElementById("heartbeat");
const priceLabel = document.getElementById("priceLabel");
const updatedLabel = document.getElementById("updatedLabel");
const flowBar = document.getElementById("flowBar");

const tradesBody = document.getElementById("trades-body");
const feedBtn = document.getElementById("feedBtn");
const tradeBtn = document.getElementById("tradeBtn");

/********* Helpers *********/
const clamp = (v, a=0, b=1) => Math.max(a, Math.min(b, v));
const nowHHMMSS = () => {
  const d = new Date();
  const p2 = x => String(x).padStart(2,"0");
  return `${p2(d.getHours())}:${p2(d.getMinutes())}:${p2(d.getSeconds())}`;
};
const fmtUSD = v => `$${Number(v).toFixed(2)}`;

/********* State *********/
let W=0,H=0, CX=0, CY=0, t=0;
let HEALTH = 0.48;   // 0..1
let MUT = 0.08;      // 0..1
let STAGE = 1;
let FLOW = 0.50;     // 0..1 left->right needle
let PRICE = 0.01;

/********* Canvas size *********/
function resizeCanvas(){
  canvas.width = W = window.innerWidth;
  canvas.height = H = window.innerHeight;
  CX = W/2; CY = H/2;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/********* Creature visuals *********/
const motes = Array.from({length: 34}, () => ({
  x: Math.random()*W, y: Math.random()*H,
  dx: (Math.random()-.5)*0.8, dy: (Math.random()-.5)*0.8,
  r: 0.8 + Math.random()*1.4
}));

function drawRings(){
  ctx.save();
  ctx.translate(CX, CY);
  ctx.lineWidth = 1;

  const rings = 8;
  for(let i=1;i<=rings;i++){
    const R = 90 + i*56 + Math.sin(t*0.3 + i)*2;
    const alpha = 0.10 - i*0.006;
    ctx.beginPath();
    ctx.arc(0,0,R,0,Math.PI*2);
    ctx.strokeStyle = `rgba(110,180,255,${alpha})`;
    ctx.stroke();
  }
  ctx.restore();
}

function drawNucleus(){
  const base = 44 + Math.sin(t*0.9)*2 + (HEALTH*20);
  const grad = ctx.createRadialGradient(CX, CY, 8, CX, CY, base+28);
  grad.addColorStop(0, `rgba(255,255,255,0.95)`);
  grad.addColorStop(0.25, `rgba(210,235,255,0.75)`);
  grad.addColorStop(1, `rgba(110,170,255,0.08)`);
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(CX, CY, base, 0, Math.PI*2); ctx.fill();

  // halo
  ctx.beginPath(); ctx.arc(CX, CY, base+26, 0, Math.PI*2);
  ctx.strokeStyle = `rgba(160,210,255,0.18)`; ctx.lineWidth=18; ctx.stroke();
}

function drawTether(){
  const phase = t*0.8;
  const anchorX = CX-220, anchorY = CY+80;
  const ctrlX = CX-140 + Math.sin(phase)*20;
  const ctrlY = CY+40 + Math.cos(phase*0.7)*28;
  ctx.beginPath();
  ctx.moveTo(anchorX, anchorY);
  ctx.quadraticCurveTo(ctrlX, ctrlY, CX, CY);
  ctx.strokeStyle = `rgba(180,220,255,0.35)`;
  ctx.lineCap="round"; ctx.lineWidth=6;
  ctx.stroke();
}

function drawMotes(){
  for(const m of motes){
    m.x += m.dx; m.y += m.dy;
    if(m.x < 0) m.x = W; if(m.x > W) m.x = 0;
    if(m.y < 0) m.y = H; if(m.y > H) m.y = 0;
    ctx.beginPath();
    ctx.arc(m.x, m.y, m.r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(190,220,255,0.20)";
    ctx.fill();
  }
}

function draw(){
  t += 0.016;
  ctx.clearRect(0,0,W,H);

  // faint hazy backdrop
  const haze = ctx.createRadialGradient(CX, CY, 40, CX, CY, Math.max(W,H)*0.9);
  haze.addColorStop(0, "rgba(10,18,28,0.0)");
  haze.addColorStop(1, "rgba(0,0,0,0.85)");
  ctx.fillStyle = haze; ctx.fillRect(0,0,W,H);

  drawRings();
  drawMotes();
  drawTether();
  drawNucleus();

  requestAnimationFrame(draw);
}
draw();

/********* UI setters *********/
function setHealth(p){ p=clamp(p,0,1); HEALTH=p;
  const pct = Math.round(p*100);
  healthBar.style.width = `${pct}%`;
  healthPct.textContent = pct+"%";
}
function setMutation(p){ p=clamp(p,0,1); MUT=p;
  const pct = Math.round(p*100);
  mutBar.style.width = `${pct}%`;
  mutPct.textContent = pct+"%";
}
function setStage(n){ STAGE = n; stageNum.textContent = String(n); }
function setFlow(p){ FLOW = clamp(p,0,1); flowBar.style.transform = `scaleX(${FLOW})`; }
function setPrice(v){ PRICE=v; priceLabel.textContent = Number(v).toFixed(2); }

/********* Trades rendering (DEX-style table, max 5) *********/
function renderTrades(items){
  // expect items: [{ time:"HH:MM:SS", type:"Feed"|"Starve", valueUsd:Number, priceUsd:Number }]
  tradesBody.innerHTML = "";
  const rows = items.slice(0,5); // max 5
  for(const r of rows){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="${r.type.toLowerCase()==='feed' ? 'type-feed':'type-starve'}">${r.type}</td>
      <td>${fmtUSD(r.valueUsd)}</td>
      <td>${fmtUSD(r.priceUsd)}</td>
      <td>${r.time}</td>
    `.trim();
    tradesBody.appendChild(tr);
  }
}

/********* Data sources *********/
// If you have a backend, plug these in. If not, we run a tasteful simulator.
async function fetchHealth(){
  if(!API){ return { price: PRICE, time: Date.now() }; }
  const r = await fetch(`${API}/health?mint=${encodeURIComponent(TOKEN_MINT)}`);
  return r.json();
}
async function fetchTrades(){
  if(!API){ 
    // simulated: alternate feed/starve with random USD
    const now = new Date();
    const p2 = x => String(x).padStart(2,"0");
    const tstr = `${p2(now.getHours())}:${p2(now.getMinutes())}:${p2(now.getSeconds())}`;
    const items = Array.from({length:5}).map((_,i)=>({
      time: tstr,
      type: Math.random()<0.45 ? "Feed" : "Starve",
      valueUsd: 5 + Math.random()*40,
      priceUsd: PRICE
    }));
    return items;
  }
  const r = await fetch(`${API}/trades?mint=${encodeURIComponent(TOKEN_MINT)}&limit=5`);
  return r.json();
}

/********* Buttons *********/
feedBtn.addEventListener("click", (ev)=>{
  ev.preventDefault();
  // tiny “feel” nudge
  const delta = (Math.random()*0.06)+0.04;
  setHealth( clamp(HEALTH + delta, 0,1) );
  setFlow( clamp(FLOW + 0.15, 0,1) );
});
if(DEX_URL){
  tradeBtn.href = DEX_URL;
}else{
  tradeBtn.removeAttribute("href");
}

/********* Boot + Schedules *********/
function renderTraits(){
  // simple preview: unlock chips as mutation climbs
  const row = document.getElementById("traitsRow");
  row.innerHTML = "";
  const steps = [
    { th: 0.12, label:"Gleam" },
    { th: 0.28, label:"Echo Ring" },
    { th: 0.50, label:"Eye-spark" }
  ];
  steps.filter(s=>MUT>=s.th).forEach(s=>{
    const span = document.createElement("span");
    span.className="chip";
    span.textContent = s.label;
    row.appendChild(span);
  });
}

async function tickHealth(){
  try{
    const h = await fetchHealth();
    if(h && typeof h.price === "number"){
      setPrice(h.price);
      updatedLabel.textContent = nowHHMMSS();
    }else{
      updatedLabel.textContent = nowHHMMSS();
    }
  }catch(e){ /* ignore */ }
}

async function tickTrades(){
  try{
    const items = await fetchTrades();
    // net flow pushes needle + slightly nudges health
    let net = 0;
    for(const x of items){ net += (x.type === "Feed" ? 1 : -1) * x.valueUsd; }
    const norm = clamp(0.5 + Math.tanh(net/100)/2, 0,1);
    setFlow(norm);
    setHealth( clamp(HEALTH + (norm-0.5)*0.02, 0,1) );

    // newest first
    items.sort((a,b)=> (a.time < b.time ? 1 : -1));
    renderTrades(items);
  }catch(e){ /* ignore */ }
}

function boot(){
  setStage(1);
  setHealth(HEALTH);
  setMutation(MUT);
  setFlow(0.5);
  setPrice(0.01);
  renderTraits();
  tickHealth();
  tickTrades();

  // schedules
  setInterval(()=> { updatedLabel.textContent = nowHHMMSS(); }, 6000);
  setInterval(()=>{
    const tgt = 0.55 + (FLOW-0.5)*0.2;
    const next = HEALTH + (tgt-HEALTH)*0.04;
    setHealth(clamp(next));
  }, 4000);
}
boot();
